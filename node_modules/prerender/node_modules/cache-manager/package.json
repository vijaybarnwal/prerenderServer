{
  "name": "cache-manager",
  "version": "0.2.0",
  "description": "Cache module for Node.js",
  "main": "index.js",
  "scripts": {
    "test": "make"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/BryanDonovan/node-cache-manager.git"
  },
  "keywords": [
    "cache",
    "redis",
    "lru-cache",
    "memory cache",
    "multiple cache"
  ],
  "author": {
    "name": "Bryan Donovan"
  },
  "license": "MIT",
  "dependencies": {
    "async": ">=0.1.22",
    "lru-cache": ">=2.3.0"
  },
  "devDependencies": {
    "coveralls": "~2.3.0",
    "istanbul": ">=0.1.29",
    "jshint": ">=1.0.1",
    "mocha": ">=1.8.1",
    "optimist": ">=0.3.5",
    "sinon": ">=1.5.2"
  },
  "readme": "[![build status](https://secure.travis-ci.org/BryanDonovan/node-cache-manager.png)](http://travis-ci.org/BryanDonovan/node-cache-manager)\n[![Coverage Status](https://coveralls.io/repos/BryanDonovan/node-cache-manager/badge.png?branch=master)](https://coveralls.io/r/BryanDonovan/node-cache-manager?branch=master)\n\nnode-cache-manager\n======================\n\n# Flexible NodeJS cache module\n\nA cache module for nodejs that allows easy wrapping of functions in cache,\ntiered caches, and a consistent interface.\n\n## Features\n\n* Easy way to wrap any function in cache.\n* Tiered caches -- data gets stored in each cache and fetched from the highest\npriority cache(s) first.\n* Use any cache you want, as long as it has the same API.\n* 100% test coverage via [mocha](https://github.com/visionmedia/mocha), \n  [istanbul](https://github.com/yahoo/istanbul), and [sinon](http://sinonjs.org).\n\n\n## Installation\n\n    npm install cache-manager\n\n## Overview\n\nFirst, it includes a `wrap` function that lets you wrap any function in cache.\n(Note, this was inspired by [node-caching](https://github.com/mape/node-caching).)\nThis is probably the feature you're looking for.  As an example, where you might have to do this\n\n```javascript\nfunction get_cached_user(id, cb) {\n    memory_cache.get(id, function (err, result) {\n        if (err) { return cb(err); }\n\n        if (result) {\n            return cb(null, result);\n        }\n\n        get_user(id, function (err, result) {\n            if (err) { return cb(err); }\n            memory_cache.set(id, result);\n            cb(null, result);\n        });\n    });\n}\n```\n... you can instead use the `wrap` function:\n\n```javascript\nfunction get_cached_user(id, cb) {\n    memory_cache.wrap(id, function (cache_callback) {\n        get_user(id, cache_callback);\n    }, cb);\n}\n\nget_cached_user(user_id, function (err, user) {\n    // First time fetches the user from the (fake) database:\n    console.log(user);\n\n    get_cached_user(user_id, function (err, user) {\n        // Second time fetches from cache.\n        console.log(user);\n    });\n});\n```\n\nSecond, node-cache-manager features a built-in memory cache (using [node-lru-cache](https://github.com/isaacs/node-lru-cache)),\nwith the standard functions you'd expect in most caches:\n\n    set(key, val, cb)\n    get(key, cb)\n    del(key, cb)\n\nThird, node-cache-manager lets you set up a tiered cache strategy.  This may be of\nlimited use in most cases, but imagine a scenario where you expect tons of\ntraffic, and don't want to hit your primary cache (like Redis) for every request.\nYou decide to store the most commonly-requested data in an in-memory cache,\nperhaps with a very short timeout and/or a small data size limit.  But you\nstill want to store the data in Redis for backup, and for the requests that\naren't as common as the ones you want to store in memory. This is something\nnode-cache-manager handles easily and transparently.\n\n\n## Usage Examples\n\nSee examples below and in the examples directory.  See ``examples/redis_example`` for an example of how to implement a\nRedis cache store with connection pooling.\n\n### Single Store\n\n```javascript\nvar cache_manager = require('cache-manager');\nvar memory_cache = cache_manager.caching({store: 'memory', max: 100, ttl: 10/*seconds*/});\n\n// Note: callback is optional in set() and del().\n\nmemory_cache.set('foo', 'bar', function(err) {\n    if (err) { throw err; }\n\n    memory_cache.get('foo', function(err, result) {\n        console.log(result);\n        // >> 'bar'\n        memory_cache.del('foo', function(err) {});\n    });\n});\n\nfunction get_user(id, cb) {\n    setTimeout(function () {\n        console.log(\"Returning user from slow database.\");\n        cb(null, {id: id, name: 'Bob'});\n    }, 100);\n}\n\nvar user_id = 123;\nvar key = 'user_' + user_id; \n\nmemory_cache.wrap(key, function (cb) {\n    get_user(user_id, cb);\n}, function (err, user) {\n    console.log(user);\n\n    // Second time fetches user from memory_cache\n    memory_cache.wrap(key, function (cb) {\n        get_user(user_id, cb);\n    }, function (err, user) {\n        console.log(user);\n    });\n});\n\n// Outputs:\n// Returning user from slow database.\n// { id: 123, name: 'Bob' }\n// { id: 123, name: 'Bob' }\n```\n\nHere's a very basic example of how you could use this in an Express app:\n\n```javascript\nfunction respond(res, err, data) {\n    if (err) { \n        res.json(500, err);\n    } else {\n        res.json(200, data);\n    }\n}\n\napp.get('/foo/bar', function(req, res) {\n    var cache_key = 'foo-bar:' + JSON.stringify(req.query);\n    memory_cache.wrap(cache_key, function(cache_cb) {\n        DB.find(req.query, cache_cb);\n    }, function(err, result) {\n        respond(res, err, result);\n    });\n});\n```\n\n#### Custom Stores\n\nYou can use your own custom store by creating one with the same API as the\nbuild-in memory stores (such as a redis or memcached store).  To use your own store, you can either pass\nin an instance of it, or pass in the path to the module.\n\nE.g.,\n\n```javascript\nvar my_store = require('your-homemade-store');\nvar cache = cache_manager.caching({store: my_store});\n// or\nvar cache = cache_manager.caching({store: '/path/to/your/store'});\n```\n\n### Multi-Store\n\n```javascript\nvar multi_cache = cache_manager.multi_caching([memory_cache, some_other_cache]);\nuser_id2 = 456;\nkey2 = 'user_' + user_id; \n\n// Sets in all caches.\nmulti_cache.set('foo2', 'bar2', function(err) {\n    if (err) { throw err; }\n\n    // Fetches from highest priority cache that has the key.\n    multi_cache.get('foo2', function(err, result) {\n        console.log(result);\n        // >> 'bar2'\n\n        // Delete from all caches\n        multi_cache.del('foo2');\n    });\n});\n\nmulti_cache.wrap(key2, function (cb) {\n    get_user(user_id2, cb);\n}, function (err, user) {\n    console.log(user);\n\n    // Second time fetches user from memory_cache, since it's highest priority.\n    // If the data expires in the memory cache, the next fetch would pull it from\n    // the 'some_other_cache', and set the data in memory again.\n    multi_cache.wrap(key2, function (cb) {\n        get_user(user_id2, cb);\n    }, function (err, user) {\n        console.log(user);\n    });\n});\n```\n\n## Tests\n\nTo run tests, first run:\n\n    npm install -d\n\nRun the tests and JShint:\n\n    make\n\n\n## Contribute\n\nIf you would like to contribute to the project, please fork it and send us a pull request.  Please add tests\nfor any new features or bug fixes.  Also run ``make`` before submitting the pull request.\n\n\n## License\n\nnode-cache-manager is licensed under the MIT license.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/BryanDonovan/node-cache-manager/issues"
  },
  "_id": "cache-manager@0.2.0",
  "_from": "cache-manager@0.2.0"
}
